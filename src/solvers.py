import numpy as np
from scipy.integrate import solve_ivp
from src.physics import g

def projectile_motion_numerical(t, y, g):
    """
    Численное решение уравнений движения тела с использованием метода Рунге-Кутты.

    Параметры:
    t - время
    y - вектор состоящий из [x, vx, y, vy], где:
        x - положение по оси X (горизонтальное)
        vx - скорость по оси X
        y - положение по оси Y (вертикальное)
        vy - скорость по оси Y
    g - ускорение свободного падения

    Возвращает:
    - dx/dt = vx (горизонтальная скорость)
    - dvx/dt = 0 (горизонтальное ускорение равно нулю, так как сопротивление воздуха не учитывается)
    - dy/dt = vy (вертикальная скорость)
    - dvy/dt = -g (ускорение в вертикальном направлении, равное -g, где g - ускорение свободного падения)
    """
    x, vx, y, vy = y
    return [vx, 0, vy, -g]

def solve_trajectory(v0, theta, t_max, dt=0.01):
    """
    Решает задачу о движении тела численно методом Рунге-Кутты.

    Параметры:
    v0 - начальная скорость тела (м/с)
    theta - угол запуска тела относительно горизонтали (градусы)
    t_max - максимальное время моделирования (секунды)
    dt - шаг времени для численного решения (по умолчанию 0.01)

    Возвращает:
    - t - массив временных точек
    - x - массив значений положения тела по оси X
    - y - массив значений положения тела по оси Y
    """
    # Преобразуем угол из градусов в радианы
    theta = np.radians(theta)

    # Начальные условия: [x, vx, y, vy]
    # x0 = 0 (начальное положение по горизонтали)
    # vx0 = v0 * cos(theta) (горизонтальная составляющая начальной скорости)
    # y0 = 0 (начальное положение по вертикали)
    # vy0 = v0 * sin(theta) (вертикальная составляющая начальной скорости)
    y0 = [0, v0 * np.cos(theta), 0, v0 * np.sin(theta)]

    # Генерируем временные точки для численного решения
    t_eval = np.linspace(0, t_max, int(t_max / dt))  # t_max - время моделирования, dt - шаг времени

    # Решаем систему дифференциальных уравнений методом Рунге-Кутты
    sol = solve_ivp(projectile_motion_numerical, [0, t_max], y0, t_eval=t_eval, args=(g,))

    # Возвращаем:
    # t - временные точки
    # sol.y[0] - положения по оси X
    # sol.y[2] - положения по оси Y
    return sol.t, sol.y[0], sol.y[2]
